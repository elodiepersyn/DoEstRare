{
    "contents" : "#include \"DoEstRare.h\"\n#include <stdio.h>\n\n/*\n * geno_cas\n * geno_ctrl\n * Na\n * Nu\n * l : vector of positions\n * from : start of densoty estimation\n * to : end of density estimation\n * P : number of positions\n * bw :  bandwidth\n * chra: number of chromosomes in cases\n * chru: number of chromosomes in controls\n */\n\nvoid DoEstRare_test_adaptive(double* stat_, double* pval_, double* X_, double* Y, double* N_, double* P_, double* autosomal_, double* gender, double* l, double* from_, double* to_, double*  bw_, double* b_, double* r_ ){\n  int N=N_[0];\n  int P=P_[0];\n  int from=from_[0];\n  int to=to_[0];\n  double bw=bw_[0];\n  double r=r_[0];\n  double b=b_[0];\n  int autosomal=autosomal_[0];\n\n  //TRANSFORM X INTO A MATRIX\n  double** X;\n  X=(double**)malloc(N*sizeof(double*));\n  int i=0;\n  for(i=0; i<N; i++){\n    X[i]=(double*)malloc(P*sizeof(double));\n  }\n\n  createMatrixFromRVector(X, X_, N, P);\n\n  double stat_obs=0;\n  stat_obs=DoEstRare_stat(X, Y, N, P, autosomal, gender, l, from, to, bw);\n\n  //ADAPTIVE PERMUTATIONS\n  double* Yperm=malloc(N*sizeof(double));\n  double stat_perm=0;\n  double j=1;\n  double R=0;\n\n  while(R<r && j<b){\n    permutate(Y, Yperm, N); //a faire\n    stat_perm=DoEstRare_stat(X, Yperm, N, P, autosomal, gender, l, from, to, bw);\n    if(stat_perm>=stat_obs){\n      R=R+1;\n    }\n    j=j+1;\n  }\n\n  if(j<b){\n    pval_[0]=R/(j-1);\n  }else{\n    pval_[0]=(R+1)/(b+1);\n  }\n\n  stat_[0]=stat_obs;\n\n  //FREE\n  for(i=0; i<N; i++){\n    free(X[i]);\n  }\n  free(X);\n  free(Yperm);\n}\n\nvoid DoEstRare_test_standardperm(double* stat_, double* pval_, double* X_, double* Y, double* N_, double* P_, double* autosomal_, double* gender, double* l, double* from_, double* to_, double*  bw_, double* perm_){\n  int N=N_[0];\n  int P=P_[0];\n  int from=from_[0];\n  int to=to_[0];\n  double bw=bw_[0];\n  double perm=perm_[0];\n  int autosomal=autosomal_[0];\n\n  //TRANSFORM X INTO A MATRIX\n  double** X;\n  X=(double**)malloc(N*sizeof(double*));\n  int i=0;\n  for(i=0; i<N; i++){\n    X[i]=(double*)malloc(P*sizeof(double));\n  }\n\n  createMatrixFromRVector(X, X_, N, P);\n\n  double stat_obs=0;\n  stat_obs=DoEstRare_stat(X, Y, N, P, autosomal, gender, l, from, to, bw);\n\n  //PERMUTATIONS\n  double* Yperm=malloc(N*sizeof(double));\n  double stat_perm=0;\n  double R=0;\n\n  for(i=0; i<perm; i++){\n    permutate(Y, Yperm, N); //a faire\n    stat_perm=DoEstRare_stat(X, Yperm, N, P, autosomal, gender, l, from, to, bw);\n    if(stat_perm>=stat_obs){\n      R=R+1;\n    }\n  }\n\n  pval_[0]=(R+1)/(perm+1);\n\n  stat_[0]=stat_obs;\n\n  //FREE\n  for(i=0; i<N; i++){\n    free(X[i]);\n  }\n  free(X);\n  free(Yperm);\n}\n\n\ndouble DoEstRare_stat(double** X, double* Y, int N, int P, int autosomal, double* gender, double* l, int from, int to, double  bw){\n\n  //COMPUTATION OF CHROMOSOME NUMBERS IN CASES AND CONTROLS\n  int Na=0;\n  int i=0;\n  for(i=0; i<N; i++){\n    if(Y[i]==1){\n      Na=Na+1;\n    }\n  }\n\n  int chra=0, chru=0;\n  if(autosomal==1){\n    chra=2*Na;\n    chru=2*(N-Na);\n  }else{\n    for(i=0; i<N; i++){\n      if(Y[i]==1){\n        chra=chra+gender[i];\n      }else{\n        chru=chru+gender[i];\n      }\n    }\n  }\n\n  //COMPUTATION OF MUTATION COUNTS IN CASES AND CONTROLS\n  double* ma=malloc(P*sizeof(double)); //numeric vector of mutation counts in cases for each variant\n  double* mu=malloc(P*sizeof(double)); // numeric vector of mutation counts in controls for each variant\n  initialize(ma,P);\n  initialize(mu,P);\n  colSum_case(ma, X, Y, N, P);\n  colSum_ctrl(mu, X, Y, N, P);\n\n  //COMPUTATION OF WEIGHTS\n  double* weights=malloc(P*sizeof(double));\n  initialize(weights, P);\n  for(i=0; i<P;i++){\n    //R : pbinom(q=x[1], size=2*Na,prob=(x[2]+1)/(2*Nu+2),lower.tail=T)\n    // fonction pbinom dans Rmath.h : double pbinom(double x, double n, double p, int lower_tail, int log_p)\n    weights[i]=pbinom(ma[i], chra, (mu[i]+1)/(chru+1), 1, 0);\n  }\n\n  //COMPUTATION OF BURDEN COMPONENTS\n  double Pa=0;\n  double Pu=0;\n  for(i=0; i<P;i++){\n    Pa=Pa+ma[i]*weights[i];\n    Pu=Pu+mu[i]*weights[i];\n  }\n  Pa=Pa/(chra*P)/sum(weights,P);\n  Pu=Pu/(chru*P)/sum(weights,P);\n\n  //COMPUTATION OF DENSITIES\n  double * dens_cas=malloc((to-from+1)*sizeof(double));\n  double * dens_ctrl=malloc((to-from+1)*sizeof(double));\n  double * w=malloc(P*sizeof(double));\n\n  initialize(dens_cas, P);\n  initialize(dens_ctrl, P);\n  initialize(w, P);\n\n  double sum_ma=0;\n  double sum_mu=0;\n  sum_ma=sum(ma, P);\n  sum_mu=sum(mu, P);\n\n  if(sum_ma!=0){\n    proport(w, ma, P);\n    densite(l, w, from, to, P, bw, dens_cas);\n  }\n\n  if(sum_mu!=0){\n    proport(w, mu, P);\n    densite(l, w, from, to, P, bw, dens_ctrl);\n  }\n\n  //COMPUTATION OF STATISTIC\n  double* diff=malloc((to-from+1)*sizeof(double));\n  initialize(diff, (to-from+1));\n  for(i=0; i<(to-from+1); i++){\n    diff[i]=Pa*dens_cas[i]-Pu*dens_ctrl[i];\n    if(diff[i]<0){\n      diff[i]=-diff[i];\n    }\n  }\n  double* vect_int=malloc((to-from)*sizeof(double));\n  initialize(vect_int, to-from);\n  for(i=0; i<(to-from); i++){\n    vect_int[i]=(diff[i]+diff[i+1])/2;\n  }\n\n  double stat=0;\n  stat=sum(vect_int,to-from);\n\n  //printf(\"%f \\n\", stat[0]);\n\n  free(ma);\n  free(mu);\n  free(weights);\n  free(w);\n  free(diff);\n  free(dens_cas);\n  free(dens_ctrl);\n  free(vect_int);\n\n  return stat;\n}\n\n\n",
    "created" : 1490017800773.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2152496021",
    "id" : "694E1ECA",
    "lastKnownWriteTime" : 1489763847,
    "path" : "~/elodie/PACKAGE_R/DOESTRARE_PROPRE/DoEstRare1.5/src/DoEstRare.c",
    "project_path" : "src/DoEstRare.c",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "c"
}